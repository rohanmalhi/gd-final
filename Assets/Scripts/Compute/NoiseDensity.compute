#pragma kernel Density
#include "Includes/Density.compute"
#include "Includes/Noise.compute"
#include "Includes/FastNoiseLite.compute"

// Noise settings
StructuredBuffer<float3> offsets;
int octaves;
float lacunarity;
float persistence;
float noiseScale;
float noiseWeight;
float floorOffset;
float weightMultiplier;
bool closeEdges;
float hardFloor;
float hardFloorWeight;
float radius;



float4 params; 

float expScale(float x)
{
    return 1 / (1.9 + pow(3, -7 * (x - 0.9))) + 0.5;
}

[numthreads(numThreads,numThreads,numThreads)]
void Density (int3 id : SV_DispatchThreadID)
{
    if (id.x >= numPointsPerAxis || id.y >= numPointsPerAxis || id.z >= numPointsPerAxis) {
        return;
    }

    float3 pos = centre + id * spacing - boundsSize/2;
    
    // noise
    fnl_state state = fnlCreateState(1337);
    state.noise_type = FNL_NOISE_OPENSIMPLEX2;
    state.fractal_type = FNL_FRACTAL_DOMAIN_WARP_INDEPENDENT;
    state.frequency = .002f;
    // end noise 

    float modNoiseWeight = expScale(fnlGetNoise2D(state, pos.x + offsets[0] + offset.x, pos.z + offsets[0] + offset.z)) * noiseWeight;
    // float modNoiseWeight = GaussianFunction(pos.x, pos.z);
    // float modNoiseWeight = noiseWeight;
    
    float offsetNoise = 0;

    float noise = 0;

    float frequency = noiseScale/100;
    float amplitude = expScale(fnlGetNoise2D(state, pos.x + offsets[0] + offset.x, pos.z + offsets[0] + offset.z)) * 2;
    // float amplitude = GaussianFunction10(pos.x, pos.z) * 2.15;
    // float amplitude = 1.5f;
    float weight = 1;
    for (int j =0; j < octaves; j ++) {
        float n = snoise((pos+offsetNoise) * frequency + offsets[j] + offset);
        float n1 = snoise(pos * (frequency/300));
        float n2 = snoise((pos-offsetNoise) * (frequency/50) - offsets[j] - offset);
        n = n * 0.4 + n1 * 0.3 + n2 * 0.3;
        float v = 1 - abs(n);
        v = v*v*v*v;
        v *= weight;
        weight = max(min(v*weightMultiplier,1),0);
        noise += v * amplitude;
        amplitude *= persistence;
        frequency *= lacunarity;
    }

    
    float finalVal =  -(pos.y + floorOffset) + noise * modNoiseWeight;

    if (pos.y < hardFloor) {
        finalVal += hardFloorWeight;
    }
    
    if (closeEdges) {
        float3 edgeOffset = abs(pos*2)-worldSize + spacing/2;
        float edgeWeight = saturate(sign(max(max(edgeOffset.x,edgeOffset.y),edgeOffset.z)));
        finalVal = finalVal * (1-edgeWeight) - 100 * edgeWeight;
        
    }

    int index = indexFromCoord(id.x,id.y,id.z);
    
    points[index] = float4(pos, finalVal);
    
}
